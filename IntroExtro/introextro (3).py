# -*- coding: utf-8 -*-
"""IntroExtro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NginH4-HES5-M1Q8EW0ja6ERCUzSCxfZ
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('introextrotrain.csv')

def clean_data(df):

    #Initialize values using regular if-else blocks
    if 'Time_spent_Alone' in df.columns and not df['Time_spent_Alone'].empty:
        mean_time_alone = df['Time_spent_Alone'].mean()
    else:
        mean_time_alone = None

    if 'Stage_fear' in df.columns and not df['Stage_fear'].empty:
        mode_stage_fear = df['Stage_fear'].mode()[0]
    else:
        mode_stage_fear = None

    if 'Social_event_attendance' in df.columns and not df['Social_event_attendance'].empty:
        mean_social_fear = df['Social_event_attendance'].mean()
    else:
        mean_social_fear = None

    if 'Going_outside' in df.columns and not df['Going_outside'].empty:
        going_out = df['Going_outside'].mean()
    else:
        going_out = None

    if 'Drained_after_socializing' in df.columns and not df['Drained_after_socializing'].empty:
        drained_after_social = df['Drained_after_socializing'].mode()[0]
    else:
        drained_after_social = None

    if 'Friends_circle_size' in df.columns and not df['Friends_circle_size'].empty:
        friend_circle_size = df['Friends_circle_size'].mean()
    else:
        friend_circle_size = None

    if 'Post_frequency' in df.columns and not df['Post_frequency'].empty:
        post_freq = df['Post_frequency'].mean()
    else:
        post_freq = None



    #Fill missing values
    if mean_time_alone is not None:
        df['Time_spent_Alone'].fillna(mean_time_alone, inplace=True)
    if mode_stage_fear is not None:
        df['Stage_fear'].fillna(mode_stage_fear, inplace=True)
    if mean_social_fear is not None:
        df['Social_event_attendance'].fillna(mean_social_fear, inplace=True)
    if going_out is not None:
        df['Going_outside'].fillna(going_out, inplace=True)
    if drained_after_social is not None:
        df['Drained_after_socializing'].fillna(drained_after_social, inplace=True)
    if friend_circle_size is not None:
        df['Friends_circle_size'].fillna(friend_circle_size, inplace=True)
    if post_freq is not None:
        df['Post_frequency'].fillna(post_freq, inplace=True)


    #Since these 2 features are boolean values, map yes to 1 and no to 0
    if 'Stage_fear' in df.columns:
        df["Stage_fear"] = df["Stage_fear"].map({"Yes": 1, "No": 0})
    if 'Drained_after_socializing' in df.columns:
        df["Drained_after_socializing"] = df["Drained_after_socializing"].map({"Yes": 1, "No": 0})


    return df


df = clean_data(df)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

df_test = pd.read_csv('introextrotest.csv')
df_test['Personality'] = None # Add an empty Personality column
df_test = clean_data(df_test)

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import confusion_matrix, f1_score, accuracy_score

#1. Prepare training data (from df)
y = df['Personality']
X = df.drop(['Personality', 'id'], axis=1)

#2. Split training data for evaluation
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=0)

#3. Scale features
sc_X = StandardScaler()
X_train = sc_X.fit_transform(X_train)
X_val = sc_X.transform(X_val)

#4. Train KNN classifier
classifier = KNeighborsClassifier(n_neighbors=11, p=2, metric='euclidean')
classifier.fit(X_train, y_train)

#5. Prepare test data for prediction
X_final_test = df_test.drop(['Personality', 'id'], axis=1)
X_final_test = sc_X.transform(X_final_test)

#6. Predict on test data
y_pred = classifier.predict(X_final_test)

#7. Save ID + predicted personality to CSV
output_df = pd.DataFrame({
    'id': df_test['id'],
    'Predicted_Personality': y_pred
})
output_df.to_csv("predicted_personality_output1.csv", index=False)

"""Cell 1: Creates dataframe, calculates missing values with mode/mean(depending on categorical/numerical data), fills in missing values. No values are largely missing, so all columns are full."""

