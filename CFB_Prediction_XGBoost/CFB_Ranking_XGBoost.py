# -*- coding: utf-8 -*-
"""CFBPrediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LhvBeN-xiSxKFN1uPSLc0WCt9pGYqqCD
"""

import pandas as pd
import re

df1 = pd.read_csv('cfb13.csv')
df2 = pd.read_csv('cfb14.csv')
df3 = pd.read_csv('cfb15.csv')
df4 = pd.read_csv('cfb16.csv')
df5 = pd.read_csv('cfb17.csv')
df6 = pd.read_csv('cfb18.csv')
df7 = pd.read_csv('cfb19.csv')
df8 = pd.read_csv('cfb20.csv')
df9 = pd.read_csv('cfb21.csv')
df10 = pd.read_csv('cfb22.csv')
df11 = pd.read_csv('cfb23.csv')

#This function will define which team won. This will be the target value
def label_champion(winning_team, df):
    #Create the champion column
    champion_col = df['Team'].apply(lambda team: 1 if team == winning_team else 0)

    #Get the index of the 'Team' column
    team_index = df.columns.get_loc('Team')

    #Insert 'champion' right after 'Team'
    df.insert(team_index + 1, 'Champion', champion_col)

    return df

#This function will make the conference into a feature. It can now be used as data to predict winner.
#This function will make the conference into a feature. It can now be used as data to predict winner.
def extract_conference(df):
    df['Conference'] = df['Team'].str.extract(r'\((.*?)\)', expand=False)
    df['Team'] = df['Team'].str.replace(r'\s*\(.*?\)', '', regex=True)

    # Create a new column for numerical conference values
    df['Conference_Numerical'] = 0  # Initialize with a default value (e.g., for independents)

    # Use boolean indexing to assign values based on conference name
    df.loc[df['Conference'] == 'SEC', 'Conference_Numerical'] = 10
    df.loc[df['Conference'] == 'Big Ten', 'Conference_Numerical'] = 9
    df.loc[df['Conference'] == 'Pac-12', 'Conference_Numerical'] = 7
    df.loc[df['Conference'] == 'Big 12', 'Conference_Numerical'] = 7
    df.loc[df['Conference'] == 'ACC', 'Conference_Numerical'] = 6
    df.loc[df['Conference'] == 'AAC', 'Conference_Numerical'] = 5
    df.loc[df['Conference'] == 'Mountain West', 'Conference_Numerical'] = 4
    df.loc[df['Conference'] == 'Sun Belt', 'Conference_Numerical'] = 3
    df.loc[df['Conference'] == 'C-USA', 'Conference_Numerical'] = 3
    df.loc[df['Conference'] == 'MAC', 'Conference_Numerical'] = 2
    # For 'FBS independents', the value remains 5 from the initialization

    # You might want to drop the original 'Conference' column after this if you only need the numerical one
    df = df.drop('Conference', axis=1)

    return df

import pandas as pd

# Assume df1, df2, ..., df11 are already loaded as DataFrames

def remove_columns_from_dfs(dfs, columns_to_remove):
    modified_dfs = []
    for df in dfs:
        # Check if the columns exist in the DataFrame before dropping
        existing_columns_to_remove = [col for col in columns_to_remove if col in df.columns]
        if existing_columns_to_remove:
            df = df.drop(columns=existing_columns_to_remove)
        modified_dfs.append(df)
    return modified_dfs

columns_to_remove = ['Off.Rank', 'Off.Plays', 'Off.Yards',
                     'Total.TDs', 'Off.Yards.per.Game', 'Def.Rank',
                     'Def.Plays', 'First.Down.Rank', 'First.Down.Runs',
                     'First.Down.Passes', 'Opp.First.Down.Runs',
                     'Opp.First.Down.Passes', 'Opp.First.Down.Penalties',
                     'X4th.Down.Rank', 'X4th.Conversions',
                     'Opp.4th.Conversion', 'Opp.4th.Attempt',
                     'Kickoff.Return.Rank', 'Kickoffs.Returned',
                     'Kickoff.Return.Yards', 'Passing.Off.Rank',
                     'Pass.Def.Rank', 'Opp.Pass.Attempts', 'Penalty.Rank',
                     'Penalties', 'Penalty.Yards', 'Punt.Return.Rank',
                     'Punt.Returns', 'Net.Punt.Return.Yards',
                     'Punt.Return.Touchdowns', 'Avg.Yards.Per.Punt.Return',
                     'Punt.Return.Def.Rank', 'Opp.Punt.Returns',
                     'Opp.Punt.Return.Touchdowns.Allowed', 'Redzone.Off.Rank',
                     'Redzone.Def.Rank', 'Opp.Redzone.Attempts',
                     'Opp.Readzone.Rush.TD.Allowed',
                     'Opp.Redzone.Pass.Touchdowns.Allowed',
                     'Opp.Redzone.Field.Goals.Made', 'Rushing.Off.Rank',
                     'Rush.Yds', 'Rushing.Def.Rank', 'Opp.Rush.Yards.Alloweed',
                     'Sack.Rank', 'Sacks', 'Scoring.Def.Rank', 'Opp.Safety',
                     'Avg.Points.per.Game.Allowed', 'X2.Point.Conversions',
                     'Tackle.for.Loss.Rank', 'Solo.Tackle.For.Loss',
                     'Assist.Tackle.For.Loss', 'Total.Tackle.For.Loss',
                     'X3rd.Down.Rank', 'X3rd.Attempts', 'X3rd.Conversions',
                     'X3rd.Down.Def.Rank', 'Opp.3rd.Conversion',
                     'Opp.3rd.Attempt', 'Average.Time.of.Possession.per.Game',
                     'Time.of.Possession', 'Turnover.Rank', 'Fumbles.Recovered']

# FIX: Extract the DataFrame from the returned list
df1 = remove_columns_from_dfs([df1], columns_to_remove)[0]
df2 = remove_columns_from_dfs([df2], columns_to_remove)[0]
df3 = remove_columns_from_dfs([df3], columns_to_remove)[0]
df4 = remove_columns_from_dfs([df4], columns_to_remove)[0]
df5 = remove_columns_from_dfs([df5], columns_to_remove)[0]
df6 = remove_columns_from_dfs([df6], columns_to_remove)[0]
df7 = remove_columns_from_dfs([df7], columns_to_remove)[0]
df8 = remove_columns_from_dfs([df8], columns_to_remove)[0]
df9 = remove_columns_from_dfs([df9], columns_to_remove)[0]
df10 = remove_columns_from_dfs([df10], columns_to_remove)[0]
df11 = remove_columns_from_dfs([df11], columns_to_remove)[0]

df1 = label_champion('Florida St. (ACC)', df1)
df2 = label_champion('Ohio St. (Big Ten)', df2)
df3 = label_champion('Alabama (SEC)', df3)
df4 = label_champion('Clemson (ACC)', df4)
df5 = label_champion('Alabama (SEC)', df5)
df6 = label_champion('Clemson (ACC)', df6)
df7 = label_champion('LSU (SEC)', df7)
df8 = label_champion('Alabama (SEC)', df8)
df9 = label_champion('Georgia (SEC)', df9)
df10 = label_champion('Georgia (SEC)', df10)
df11 = label_champion('Michigan (Big Ten)', df11)

df1 = extract_conference(df1)
df2 = extract_conference(df2)
df3 = extract_conference(df3)
df4 = extract_conference(df4)
df5 = extract_conference(df5)
df6 = extract_conference(df6)
df7 = extract_conference(df7)
df8 = extract_conference(df8)
df9 = extract_conference(df9)
df10 = extract_conference(df10)
df11 = extract_conference(df11)

import sqlite3
import pandas as pd

conn = sqlite3.connect('cfbdata13-23.db')

df1.to_sql('2013', conn, if_exists='replace', index=False)
df2.to_sql('2014', conn, if_exists='replace', index=False)
df3.to_sql('2015', conn, if_exists='replace', index=False)
df4.to_sql('2016', conn, if_exists='replace', index=False)
df5.to_sql('2017', conn, if_exists='replace', index=False)
df6.to_sql('2018', conn, if_exists='replace', index=False)
df7.to_sql('2019', conn, if_exists='replace', index=False)
df8.to_sql('2020', conn, if_exists='replace', index=False)
df9.to_sql('2021', conn, if_exists='replace', index=False)
df10.to_sql('2022', conn, if_exists='replace', index=False)
df11.to_sql('2023', conn, if_exists='replace', index=False)

tables = pd.read_sql_query("SELECT name FROM sqlite_master WHERE type='table';", conn)
print("Tables:", tables)

conn.close()

"""Cell 1: Converts every csv file into a pandas dataframe. Defines the champion of each season as a boolean value. Also seperates the team name from the team conference. This way, the conference can be used as a feature to predict the champion.

This is important, since conference competitiveness can affect how impressive stats are.

Cell 2: Creates a .db file with SQL. Includes 11 tables, each of which is a csv file populated with D1 CFB data of the respective year
"""

import pandas as pd
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

combined_df = pd.concat([df4,df5,df6,df7], ignore_index=True)

def train_xgboost(df, target_column):
  X = df.drop(columns=['Champion','Team'])
  '''Drop every column thats considered a feature,
  Champion is the target column and Team will be used to identify'''
  y = df['Champion']
  #Set y to target column

  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

  #Set hyperparameters(these are just ones made by chatgpt)
  model = xgb.XGBClassifier(
        n_estimators=100,
        max_depth=4,
        learning_rate=0.1,
        use_label_encoder=False,
        eval_metric='logloss'
    )
  model.fit(X_train, y_train)

  # Predict and evaluate
  y_pred = model.predict(X_test)
  acc = accuracy_score(y_test, y_pred)
  print(f"Accuracy: {acc:.4f}")

  return model

trained_model = train_xgboost(combined_df, 'Champion')

"""Cell 3: Trains the model with "Champion" as the target and every other statistic as the features. Training data is a combination of data from the 4 seasons"""

import pandas as pd
import xgboost as xgb
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

df_new = df8.copy() #Copy of DF8

#Prepare new df for testing

#Should be identical to training data other than champ column
if 'Champion' in df_new.columns:
    X_new = df_new.drop(columns=['Champion', 'Team'])
else:
    # If 'Champion' is not in df_new, just drop 'Team'
    X_new = df_new.drop(columns=['Team'])


# --- Make Predictions on the New DataFrame ---

y_pred_new = trained_model.predict(X_new)

# --- Evaluate Predictions (if you have the actual outcomes in df_new) ---

if 'Champion' in df_new.columns:
    y_true_new = df_new['Champion']

    # Evaluate the model on the new data
    accuracy_new = accuracy_score(y_true_new, y_pred_new)
    print(f"Accuracy on the new data: {accuracy_new:.4f}")

    print("\nClassification Report on New Data:")
    print(classification_report(y_true_new, y_pred_new))

    print("\nConfusion Matrix on New Data:")
    print(confusion_matrix(y_true_new, y_pred_new))
else:
    print("Cannot evaluate accuracy as the 'Champion' column is not present in the new DataFrame.")

# You can also see the predictions for each team in the new DataFrame
# Add the predictions back to the new DataFrame for easier viewing
df_new['Predicted_Champion'] = y_pred_new

pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)

import pandas as pd
import xgboost as xgb

# Create a copy of df_new for prediction to avoid modifying the original df_new
df_for_prediction = df_new.copy()

# Get the list of feature columns used during training
training_columns = combined_df.drop(columns=['Champion', 'Team']).columns

#Drop the 'Predicted_Champion' and 'Team' columns from the prediction dataframe
X_for_proba = df_for_prediction.drop(columns=['Predicted_Champion', 'Team'], errors='ignore')

#Ensure the columns are in the same order as the training data features
X_for_proba = X_for_proba[training_columns]

#Apply any necessary preprocessing to X_for_proba if it wasn't applied earlier
if 'Average.Time.of.Possession.per.Game' in X_for_proba.columns:
    #Define the time_to_seconds function if it's not already defined
    def time_to_seconds(time_str):
        if pd.isna(time_str):
            return 0  #Or handle missing values as appropriate
        try:
            minutes, seconds = map(int, time_str.split(':'))
            return minutes * 60 + seconds
        except ValueError:
            return 0 #Handle cases where the format is unexpected

    X_for_proba['Average.Time.of.Possession.per.Game'] = X_for_proba['Average.Time.of.Possession.per.Game'].apply(time_to_seconds)



#Get the probabilities for each class (0 and 1) using the prepared data
y_pred_proba = trained_model.predict_proba(X_for_proba)

#The second column (index 1) of y_pred_proba contains the probabilities for the positive class (Champion=1)
champion_probabilities = y_pred_proba[:, 1]

#Add the probabilities to the original df_new DataFrame (which still has 'Predicted_Champion')
df_new['Champion_Probability'] = champion_probabilities

# Sort the DataFrame by Champion Probability in descending order
df_sorted_by_proba = df_new.sort_values(by='Champion_Probability', ascending=False)

# Print the teams and their predicted champion probabilities
print("\nPredictions for the new data with probabilities:")
# Select and display only the 'Team' and 'Champion_Probability' columns
display(df_sorted_by_proba[['Team', 'Champion_Probability']])